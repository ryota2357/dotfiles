[[plugins]]
repo = 'Shougo/pum.vim'
on_event = ['InsertEnter', 'CmdlineEnter']
hook_add = '''
  inoremap <expr><C-n>  pum#visible() ? pum#map#select_relative(+1) : '<Cmd>normal! gj<CR>'
  inoremap <expr><C-p>  pum#visible() ? pum#map#select_relative(-1) : '<Cmd>normal! gk<CR>'
  inoremap <expr><Down> pum#visible() ? pum#map#select_relative(+1) : '<Cmd>normal! gj<CR>'
  inoremap <expr><Up>   pum#visible() ? pum#map#select_relative(-1) : '<Cmd>normal! gk<CR>'
  " <CR> は lexima.vim で定義
'''
hook_source = '''
  call pum#set_option(#{
    \   auto_select: v:true,
    \   use_complete: v:true,
    \   scrollbar_char: '',
    \ })
  call pum#set_local_option('c', #{
    \   padding: v:true,
    \   auto_select: v:false,
    \   reversed: v:true
    \ })
'''

[[plugins]]
repo = 'rcarriga/nvim-notify'
on_lua = 'notify'
lua_add = '''
    vim.notify = function(...)
        vim.notify = require('notify')
        vim.notify.setup {
            level = 0
        }
        vim.notify(...)
    end
'''

[[plugins]]
repo = 'github/copilot.vim'
on_cmd = 'Copilot'

[[plugins]]
repo = 'cohama/lexima.vim'
rev = 'feature/feedkeys'
depends = 'pum.vim'
on_event = 'InsertEnter'
hook_add = '''
  let g:lexima_no_default_rules = v:true
  let g:lexima_map_escape = ''
  let g:lexima_accept_pum_with_enter = v:false
  autocmd FileType ddu-ff-filter let b:lexima_disabled = v:true
'''
lua_source = '''
    vim.fn['lexima#clear_rules']()

    for _, rule in ipairs({
        { char = [=[(]=],    input_after = [=[)]=], except = [=[\\\%#]=] },
        { char = [=[[]=],    input_after = [=[]]=], except = [=[\\\%#]=] },
        { char = [=[{]=],    input_after = [=[}]=], except = [=[\\\%#]=] },
        { char = [=["]=],    input_after = [=["]=], except = [=[\\\%#]=] },
        { char = [=[']=],    input_after = [=[']=], except = [=[\(\\\|<\|&\)\%#]=] },
        { char = [=[`]=],    input_after = [=[`]=], except = [=[\\\%#]=] },
        { char = [=[)]=],    at = [=[(\%#)]=],      leave = 1 },
        { char = [=[]]=],    at = [=[\%#\]]=],      leave = 1 },
        { char = [=[,]=],    input = [=[, ]=] },
        { char = [=[<BS>]=], at = [=[(\%#)]=],      delete = 1 },
        { char = [=[<BS>]=], at = [=[\[\%#\]]=],    delete = 1 },
        { char = [=[<BS>]=], at = [=[{\%#}]=],      delete = 1 },
        { char = [=[<BS>]=], at = [=["\%#"]=],      delete = 1 },
        { char = [=[<BS>]=], at = [=['\%#']=],      delete = 1 },
        { char = [=[<BS>]=], at = [=[`\%#`]=],      delete = 1 },
        { char = [=[<CR>]=], at = [=[{\%#}]=],      input_after = [=[<CR>]=] },
        { char = [=[<CR>]=], at = [=[(\%#)]=],      input_after = [=[<CR>]=] },
        { char = [=[<CR>]=], at = [=[, \%#]=],      input = [=[<BS><CR>]=] }
    }) do
        vim.fn['lexima#add_rule'](rule)
    end

    for filetype, rules in pairs({
        tex = {
            { char = [=[$]=],    input_after = [=[$]=] },
            { char = [=[<BS>]=], at = [=[\$\%#\$]=],        delete = 1 },
            { char = [=[<CR>]=], at = [=[^ *\\item.*\%#]=], input = [=[<CR>\item ]=], except = [=[\\\\\%#]=] },
        },
        cs = {
            { char = [=[<CR>]=], at = [=[ {\%#}]=],    input = [=[<BS><BS><CR>{<CR>]=], input_after = [=[<CR>]=] },
            { char = [=[<CR>]=], at = [=[[^ ]{\%#}]=], input = [=[<BS><CR>{<CR>]=],     input_after = [=[<CR>]=] },
        },
        typescriptreact = {
            { char = [=[>]=],    at = [=[<\(\w\+\)\%#]=],      input_after = [=[</\1>]=], with_submatch = true },
            { char = [=[<CR>]=], at = [=[<\w\+>\%#<\/\w\+>]=], input_after = [=[<CR>]=] },
        },
        pdf = {
            { char = [=[<]=],    at = [=[<\%#]=],    input_after = [=[>>]=] },
            { char = [=[<CR>]=], at = [=[<<\%#>>]=], input_after = [=[<CR>]=] }
        }
    }) do
        for _, rule in ipairs(rules) do
            rule.filetype = filetype
            vim.fn['lexima#add_rule'](rule)
        end
    end
    vim.cmd [[
      execute printf("inoremap <expr><silent> <CR> pum#visible() ? pum#map#confirm() : lexima#expand(%s, 'i')",
                    \ string(lexima#string#to_mappable('<CR>'))
                    \ )
    ]]
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
depends = 'denops.vim'
on_cmd = 'FuzzyMotion'
lua_add = '''
    vim.g.fuzzy_motion_labels = {
        'L', 'K', 'J', 'P', 'O', 'I', 'H', 'U', 'F',
        'D', 'S', 'R', 'E', 'W', 'A', 'G', 'T', 'Y',
        'N', 'B', 'M', 'V', 'C', 'Q', 'X', 'Z'
    }
    vim.g.fuzzy_motion_matchers = { 'fzf', 'kensaku' }
    vim.keymap.set('n', '<Leader><Space>', vim.cmd.FuzzyMotion)
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
on_event = 'BufEnter'
hook_post_update = 'TSUpdate'
lua_source = '''
    require('nvim-treesitter.configs').setup {
        ensure_installed = 'all',
        additional_vim_regex_highlighting = false,

        -- tex  : snipet挿入後とかでエラーが出る
        highlight = {
            enable = true,
            disable = { 'latex', 'tex' },
        },
    }
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-context'
depends = 'nvim-treesitter'
on_event = 'BufEnter'

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
on_event = 'BufReadPost'
hook_source = '''
  lua require'gitsigns'.setup()
'''

[[plugins]]
repo = 'lukas-reineke/indent-blankline.nvim'
on_event = 'BufEnter'
lua_source = '''
    require('rc.util').highlight.set {
        IndentBlanklineContextChar = { fg = '#6e6e6e', nocombine = true }
    }
    require('indent_blankline').setup {
        show_current_context = true,
    }
'''

[[plugins]]
repo = 'uga-rosa/ccc.nvim'
on_event = 'BufReadPost'
lua_source = '''
  local ccc = require('ccc')
  local mapping = ccc.mapping
  ccc.setup {
      bar_len = 40,
      point_char = '■',
      point_color = '#202020',
      highlighter = { auto_enable = true },
      mappings = {
          ['q'] = mapping.none,
          ['<ESC>'] = mapping.quit,
          ['<Left>'] = mapping.decrease1,
          ['<Right>'] = mapping.increase1
      }
  }
'''

[[plugins]]
repo = 'petertriho/nvim-scrollbar'
on_event = 'WinScrolled'
lua_source = '''
  require('scrollbar').setup {
      handle = { color = '#4B4B4B' },
      excluded_filetypes = {
          "vim-ui-input",
          "ddu-ff-filter",
          "ddu-filer"
      }
  }
'''

[[plugins]]
repo = 'nvim-treesitter/playground'
on_cmd = ['TSHighlightCapturesUnderCursor', 'TSPlaygroundToggle']

[[plugins]]
repo = 'cocopon/inspecthi.vim'
on_cmd = 'Inspecthi'

[[plugins]]
repo = 'tomtom/tcomment_vim'
on_cmd = 'TComment'
hook_add = '''
  let g:tcomment_maps = 0
  xnoremap _ :TComment<CR>
  nnoremap _ <Cmd>TComment<CR>
'''

[[plugins]]
repo = 'prettier/vim-prettier'
build = 'npm install'
on_ft = ['astro', 'typescriptreact', 'markdown']
hook_source = '''
  autocmd BufWritePre *.astro,*.tsx,*.md PrettierAsync
'''
hook_add = '''
  let g:prettier#config#tab_width = 2
'''

[[plugins]]
repo = 'thinca/vim-partedit'
depends = ['context_filetype.vim']
on_func = ['partedit#start']
lua_add = '''
    vim.keymap.set('n', '<Leader>e', function()
        local context = vim.fn['context_filetype#get']()
        if context == nil or context.range == { { 0, 0 }, { 0, 0 } } then
            error('[partedit] Context is not found')
            return
        end
        vim.ui.select({ 'split', 'vsplit', 'rightbelow split', 'rightbelow vsplit' }, {
            prompt = 'Select partedit opener',
            format_item = function(item)
                return 'Open as ' .. item
            end
        }, function(item, _)
            if item == nil then
                return
            end
            vim.fn['partedit#start'](context.range[1][1], context.range[2][1], {
                filetype = context.filetype,
                opener = item
            })
        end)
    end)
'''

[[plugins]]
repo = 'kat0h/bufpreview.vim'
on_ft = 'markdown'

[[plugins]]
repo = 'ryota2357/vim-skim-synctex'
# repo = '~/Projects/VimPlugin/vim-skim-synctex'
depends = 'denops.vim'
on_ft = 'tex'
hook_source = '''
  call synctex#option('readingBar', v:true)
  call synctex#option('autoQuit', v:true)
  call synctex#start()
'''
[plugins.ftplugin]
tex = '''
  nnoremap <buffer> <Leader>s <Cmd>call synctex#forwardSerch()<CR>
'''
